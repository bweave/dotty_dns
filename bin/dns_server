#!/usr/bin/env ruby

require "rubydns"
require_relative "../config/environment"

INTERFACES = [[:udp, "0.0.0.0", 5300], [:tcp, "0.0.0.0", 5300]].freeze
IN = Resolv::DNS::Resource::IN
# use Cloudflare's public family-friendls DNS servers
UPSTREAM = RubyDNS::Resolver.new([[:udp, "1.1.1.3", 53], [:tcp, "1.0.0.3", 53]])

RubyDNS.run_server(INTERFACES) do
  # log all the things so we can see what's going on
  @logger.level = :debug
  # TIL: this prevents write buffering and forces output immediately
  $stderr.sync = true

  @cache = Redis.dns_cache

  DnsRecord
    .where("domain NOT LIKE ?", "*.%")
    .in_batches(of: 10_000)
    .each do |batch|
      records = batch.pluck(:domain, :ip_address).to_h
      @cache.write_multi(records)
    end

  match(//, IN::A) do |transaction|
    cached_ip = @cache.fetch(transaction.name)
    if cached_ip
      debug "Cached answer for #{transaction.name}: #{cached_ip}"
      transaction.respond!(cached_ip)
    else
      next!
    end
  end

  DnsRecord
    .where("domain LIKE ?", "*.%")
    .find_each
    .pluck(:domain, :ip_address)
    .map do |(domain, ip_address)|
      wildcard_domain_regex = /#{domain.gsub("*.", ".+")}/

      match(wildcard_domain_regex, IN::A) do |transaction|
        debug "Wildcard answer for #{transaction.name}: #{ip_address}"
        @cache.write(transaction.name, ip_address)
        transaction.respond!(ip_address)
      end
    end

  otherwise do |transaction|
    debug "Asking upstream for #{transaction.name}"
    transaction.passthrough!(UPSTREAM) do |response|
      if response.answer.first&.[](2).is_a?(IN::A)
        ip_address = response.answer.first[2].address.to_s
        @cache.write transaction.name, ip_address
      end
    end
  end

  def debug(msg)
    logger.debug "-" * 80
    logger.debug msg
    logger.debug "-" * 80
  end
end
